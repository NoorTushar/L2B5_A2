## 3. Explain the Primary Key and Foreign Key concepts in PostgreSQL.

একটি টেবিলের এমন কোনো গুণ (attribute) কে প্রাইমারি কী (Primary Key) বলা হয়, যদি সেটি ব্যবহার করে প্রতিটি সারি (row) কে আলাদাভাবে শনাক্ত করা যায়। প্রাইমারি কী-এর মান সবসময় অদ্বিতীয় (unique) হবে এবং কখনোই ফাঁকা (NULL) থাকতে পারবে না।

সাধারণত একটি মাত্র গুণ দিয়েই প্রাইমারি কী তৈরি করা হয়। তবে কিছু ক্ষেত্রে দুই বা ততোধিক গুণ একসাথে মিলে প্রাইমারি কী তৈরি করতে হয় — একে বলা হয় কম্পোজিট প্রাইমারি কী (Composite Primary Key)।

ধরি, আমাদের একটি টেবিল আছে যার নাম "students"। এই টেবিলের গুণগুলো হলো: student_ID, student_name, student_email এবং course_ID।

এখানে প্রাইমারি কী হিসেবে আমরা দুটি অপশন পেতে পারি — একটি হলো student_ID, আরেকটি হলো student_email। এই দুই ক্ষেত্রেই মানগুলো ইউনিক বা একক, অর্থাৎ কোনো মানই বারবার আসে না। একজন ছাত্রের student_ID বা email অন্য কোনো ছাত্রের সঙ্গে কখনোই মিলে যেতে পারে না। সাধারণত এই ধরণের টেবিলে আমরা student_ID কেই প্রাইমারি কী হিসেবে ব্যবহার করি।

যদিও চাইলে আমরা student_email এবং student_name একসাথে নিয়ে কম্পোজিট প্রাইমারি কী বানাতে পারি, কিন্তু সেটি অপ্রয়োজনীয় জটিলতা তৈরি করে। তাই সহজভাবে student_ID কে প্রাইমারি কী বানালেই কাজ হয়ে যায়।

```sql
-- To create a primary key in postgresql

    CREATE TABLE students (
        student_ID INTEGER PRIMARY KEY
    )
```

এখন আসি ফরেইন কী (Foreign Key)-এর কথায়। ফরেইন কী হলো এমন একটি কী, যা অন্য একটি টেবিলের প্রাইমারি কী, এবং এটি দুইটি টেবিল বা ডেটার মধ্যে সম্পর্ক তৈরি করতে ব্যবহৃত হয়।

উদাহরণ হিসেবে, students টেবিলে যেই course_ID আছে, সেটি একটি ফরেইন কী। কারণ courses নামক আরেকটি টেবিলে course_ID এবং course name রয়েছে, এবং সেখানে course_ID হলো প্রাইমারি কী। ধরো, কোনো কোর্সের ID হলো ১০১। এখন অনেক ছাত্র এই কোর্সে ভর্তি হতে পারে। তাই students টেবিলে অনেক রেকর্ডে একই course_ID = 101 দেখা যাবে।

এটা গুরুত্বপূর্ণ কেন?

১. এটি দুটি টেবিলের মধ্যে একটি সম্পর্ক তৈরি করে।

২. ধরো, যদি কোনো কোর্সের নাম বা বিস্তারিত তথ্য পরিবর্তন করতে হয়, তাহলে শুধু courses টেবিলে একবার পরিবর্তন করলেই হবে। আমাদের আলাদাভাবে students টেবিলের প্রতিটি রোতে গিয়ে পরিবর্তন করতে হবে না। এক জায়গায় পরিবর্তন করলেই, যেসব টেবিলে ওই তথ্য রেফারেন্স করা হয়েছে, সেখানে আপডেটটি প্রতিফলিত হবে।

```sql
-- To create a foreign key in postgresql

    CREATE TABLE students (
        course_ID INTEGER REFERENCES courses(course_ID)
    )
```

## 4. What is the difference between the VARCHAR and CHAR data types?

PostgreSQL-এ VARCHAR(n) এবং CHAR(n) — দুটোই ডেটা টাইপ, যেগুলো স্ট্রিং বা অক্ষরের ডেটা সংরক্ষণের জন্য ব্যবহৃত হয়।

ধরো আমরা একটি অ্যাট্রিবিউট name নামে সংজ্ঞায়িত করছি VARCHAR(50) ব্যবহার করে। এখন, যদি আমার নাম হয় "Tushar", যার অক্ষর সংখ্যা ৬, তাহলে VARCHAR শুধুমাত্র এই ৬টি অক্ষরই সংরক্ষণ করবে এবং সেই অনুযায়ী মেমোরি ব্যবহার করবে। বাকি ৪৪টি অক্ষরের জায়গা ব্যবহার হবে না। কিন্তু যদি আমরা এমন একটি নাম দিই যেটির দৈর্ঘ্য ৫১ অক্ষরের, তাহলে VARCHAR(50) শুধু প্রথম ৫০টি অক্ষর সংরক্ষণ করবে, বাকি অংশ কেটে দেবে (truncate করবে)।

অর্থাৎ, VARCHAR কেবলমাত্র যতটুকু প্রয়োজন ততটুকু মেমোরি ব্যবহার করে এবং সর্বোচ্চ n অক্ষর পর্যন্ত ডেটা রাখতে পারে।

```sql
-- assigning VARCHAR in postgresql

CREATE TABLE students(
    student_name VARCHAR(50);
)
```

অন্যদিকে, যদি আমরা CHAR(50) ব্যবহার করি name অ্যাট্রিবিউটের জন্য এবং সেখানে "Tushar" দিই (৬ অক্ষর), তাহলে তা সম্পূর্ণ ৫০টি অক্ষরের মেমোরি বরাদ্দ করবে এবং বাকি ৪৪টি জায়গা ফাঁকা স্পেস (space) দ্বারা পূরণ করবে। যদিও ৫০টির বেশি অক্ষর গ্রহণ করবে না, কিন্তু যত কমই দিই না কেন, সবসময়ই ৫০টি অক্ষরের মতো জায়গা মেমোরিতে রিজার্ভ করে রাখবে।

```sql
-- assigning CHAR in postgresql

CREATE TABLE students(
    student_name CHAR(50);
)
```

## 6. What are the LIMIT and OFFSET clauses used for?

LIMIT এবং OFFSET — এই দুটি ক্লজ একসাথে ব্যবহার করা হয় pagination বা পাতাকরণ এর জন্য।

LIMIT কী করে?
এটি কুয়েরির মাধ্যমে সর্বোচ্চ কতটি সারি (row) দেখানো হবে, তা সীমাবদ্ধ করে।
যেমন, একটি টেবিলে ১০০টি সারি আছে এবং যদি আমরা LIMIT 10 দিই, তাহলে সেটি শুধুমাত্র ১০টি সারি দেখাবে।

OFFSET কী করে?
এটি কুয়েরিকে বলে শুরুতে কতটি সারি স্কিপ (skip) করতে হবে।
যেমন, যদি আমরা OFFSET 5 দিই, তাহলে কুয়েরি প্রথম ৫টি সারি বাদ দিয়ে পরবর্তী সারিগুলো দেখাবে (LIMIT অনুযায়ী)।

Pagination এ এটা কীভাবে সাহায্য করে?
প্রথমেই জানতে হবে Pagination কী?
একটি ওয়েব অ্যাপ্লিকেশনে যেখানে অনেক বড় ডেটাসেট থাকে, সেখানে একসাথে সব ডেটা না দেখিয়ে ধাপে ধাপে (পাতা আকারে) ছোট ছোট অংশে দেখানো হয়। এতে মেমোরি কম ব্যবহার হয় এবং ওয়েবসাইট দ্রুত কাজ করে।

উদাহরণস্বরূপ, ধরো একটি অনলাইন স্টোরে ১০,০০০টি পণ্য আছে। যদি ব্যবহারকারী প্রথমবারেই সব ১০,০০০টি পণ্য দেখে, তাহলে ওয়েবসাইট ধীর হয়ে যাবে এবং সব পণ্য একসাথে দেখানো অপ্রয়োজনীয় হবে। তাই আমরা প্রতিবার ৫০টি করে পণ্য দেখাতে পারি এবং পেজ নম্বর দিতে পারি যেমন ১, ২, ৩ ইত্যাদি।

যদি ব্যবহারকারী প্রথম পেজে ক্লিক করে, তাহলে প্রথম ৫০টি পণ্য দেখাবে:

LIMIT = 50

OFFSET = 0

যদি ব্যবহারকারী দ্বিতীয় পেজে ক্লিক করে, তাহলে প্রথম ৫০টি বাদ দিয়ে পরবর্তী ৫০টি পণ্য দেখাবে:

LIMIT = 50

OFFSET = 1 × 50 = 50

যদি ব্যবহারকারী তৃতীয় পেজে যায়, তাহলে প্রথম ১০০টি বাদ দিয়ে পরবর্তী ৫০টি দেখাবে:

LIMIT = 50

OFFSET = 2 × 50 = 100

এইভাবে প্রতিটি পেজ অনুযায়ী LIMIT এবং OFFSET এর মান পরিবর্তিত হয়।

এই যুক্তিটি আমরা নিচের ফর্মুলা দিয়ে প্রকাশ করতে পারি:

```sql

SELECT * FROM products LIMIT 50 OFFSET ((n - 1) * 50);
-- এখানে n হলো পেজ নম্বর।
```

## 8. What is the significance of the JOIN operation, and how does it work in PostgreSQL?

JOIN ব্যবহার করে আমরা দুটি টেবিলের মধ্যে সম্পর্ক (relationship) তৈরি করতে পারি। সাধারণত এই সম্পর্ক primary key এবং foreign key এর মাধ্যমে তৈরি হয়।

ধরুন, একটি customers নামের টেবিল আছে এবং আরেকটি orders নামের টেবিল আছে। orders টেবিলে একটি foreign key আছে যার নাম customer_id, যেটা বলে দেয় কোন গ্রাহক সেই অর্ডারটি করেছে। এই customer_id আসলে customers টেবিলের একটি primary key।

এখন JOIN হবে orders টেবিলের foreign key (customer_id) এবং customers টেবিলের primary key (customer_id) এর মধ্যে। JOIN করার পরে আমরা একটি টেবিলে অর্ডার সম্পর্কিত তথ্য এবং সেই অর্ডার করা গ্রাহকের তথ্য — দুটো একসাথে দেখতে পারব।

তাহলে কেন আমরা দুইটা টেবিল না করে সব ইনফরমেশন এক টেবিলে রাখি না?

কারণ এতে করে data anomalies বা ডেটা অস্বাভাবিকতা হতে পারে। ধরুন, একজন গ্রাহক ৫০টা অর্ডার করেছে, এখন তার ফোন নম্বর পরিবর্তন করতে হবে। যদি গ্রাহকের তথ্য orders টেবিলে থাকে, তাহলে আমাদের ৫০টা সারি (row) আলাদাভাবে আপডেট করতে হবে — যা সময়সাপেক্ষ এবং ভুলের সম্ভাবনা বেশি।

এর চেয়ে ভালো হলো — গ্রাহকের তথ্য শুধুমাত্র customers টেবিলে রাখা। তাহলে ফোন নম্বর শুধু এক জায়গাতেই আপডেট করলেই হবে, এবং পরবর্তীতে JOIN করলে সেই আপডেট করা তথ্য সব অর্ডারে স্বয়ংক্রিয়ভাবে দেখা যাবে।

এইভাবে JOIN:

-  সময় বাঁচায়
-  ডেটা কনসিস্টেন্ট রাখে
-  ডেটাবেস ম্যানেজমেন্ট সহজ করে

Example to create `JOIN` Operation:

```sql
CREATE TABLE customers (
  customer_id INTEGER PRIMARY KEY,
  customer_name VARCHAR(255)
);

CREATE TABLE orders (
  order_id INTEGER PRIMARY KEY,
  customer_id INTEGER REFERENCES customers(customer_id)
);

SELECT * FROM orders
    JOIN customers ON orders.customer_id = customers.customer_id;
```

## 9. Explain the GROUP BY clause and its role in aggregation operations.

GROUP BY হল SQL-এর একটি ক্লজ যেটা ব্যবহার করে একই মান বিশিষ্ট সারিগুলিকে (rows) একসাথে গ্রুপ করা হয়। এটি সাধারণত aggregate functions (যেমন COUNT(), SUM(), AVG(), MAX(), MIN()) এর সাথে ব্যবহৃত হয়।

ধরুন আমাদের একটি students নামের টেবিল আছে, যেখানে একটি country নামের কলাম আছে। এই কলামে প্রতিটি ছাত্র কোন দেশ থেকে এসেছে তা লেখা থাকে।

ধরুন মোট ১০০ জন ছাত্র আছে এবং তারা এসেছে ৪টি দেশ থেকে — Bangladesh, India, Sri Lanka, এবং Pakistan।

```sql
SELECT country
FROM students
GROUP BY country;
```

Output:

```sql
Country
--------
Bangladesh
India
Pakistan
Sri Lanka

```

এখন প্রশ্ন হচ্ছে, এমনভাবে গ্রুপিং করা কেন অ্যাগ্রিগেট অপারেশনগুলোতে সহায়তা করে?

প্রথমেই জানতে হবে, অ্যাগ্রিগেট অপারেশন কী?
অ্যাগ্রিগেট অপারেশনের একটি উদাহরণ হতে পারে এমন একটি অপারেশন, যেখানে নির্দিষ্ট একটি কলামের সকল রো একে একে গণনা করা হয় এবং একটি একক মান রিটার্ন করা হয়।

একইভাবে, যখন আমরা গ্রুপিং করি, তখন যদি SUM অপারেশন প্রয়োগ করি, তাহলে প্রতিটি গ্রুপের জন্য ঐ কলামের প্রতিটি রো-তে SUM অপারেশন চালানো হয় এবং প্রতিটি গ্রুপের জন্য আলাদা আলাদা ফলাফল দেখানো হয়।

এই কারণে আমরা গুরুত্বপূর্ণ তথ্য বের করতে পারি, যেমন — প্রতিটি দেশের মোট কতজন নাগরিক আছে তা COUNT অ্যাগ্রিগেট অপারেশন দিয়ে জানা যায়।

```
Country         |   Count
--------        |   ------
Bangladesh      |   25
India           |   10
Pakistan        |   50
Sri Lanka       |   15
```

অথবা, যদি আমরা প্রতিটি দেশের ছাত্রদের গড় নম্বর দেখতে চাই, তাহলে AVG অ্যাগ্রিগেট অপারেশন ব্যবহার করতে পারি।

এইভাবে, গ্রুপিং আমাদের বিভিন্ন ধরনের অ্যাগ্রিগেট অপারেশন ব্যবহার করে গুরুত্বপূর্ণ তথ্য বের করতে সাহায্য করে।
